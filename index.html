<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>Ghost Candle Live (REST Version)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
    }
    .app {
      max-width: 980px;
      margin: 0 auto;
      padding: 10px;
    }
    h1 {
      font-size: 1.1rem;
      text-align: center;
      margin: 4px 0;
    }
    .sub {
      font-size: 0.75rem;
      text-align: center;
      color: #9ca3af;
      margin-bottom: 8px;
    }
    .card {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 10px;
      margin-bottom: 8px;
    }
    #chart {
      width: 100%;
      height: 360px;
    }
    .info {
      font-size: 0.78rem;
      margin-top: 4px;
    }
    .info small {
      color: #9ca3af;
    }
    .status {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .status span {
      font-weight: 600;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
    }
    select {
      background: #020617;
      color: #e5e7eb;
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid #4b5563;
      font-size: 0.8rem;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(31,41,55,0.9);
      color: #9ca3af;
      margin-right: 4px;
      margin-top: 3px;
    }
    @media (max-width: 480px) {
      #chart { height: 320px; }
      .controls {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <h1>Ghost Candle Live (REST)</h1>
  <div class="sub">
    Harga real dari Binance (REST, auto-refresh).<br>
    Candle hijau/merah = market real. Candle biru di kanan = <b>ghost candle prediksi</b>.
  </div>

  <div class="card">
    <div class="controls">
      <div style="font-size:0.8rem;">Pair:</div>
      <select id="symbolSelect">
        <option value="BTCUSDT">BTCUSDT (Bitcoin)</option>
        <option value="ETHUSDT">ETHUSDT (Ethereum)</option>
        <option value="BNBUSDT">BNBUSDT (BNB)</option>
        <option value="XRPUSDT">XRPUSDT (XRP)</option>
        <option value="SOLUSDT">SOLUSDT (Solana)</option>
      </select>
      <div style="font-size:0.75rem;color:#9ca3af;">
        TF: 1 menit (interval 1m, data real-time via polling).
      </div>
    </div>
    <div class="status">
      Status: <span id="statusText">Init...</span><br>
      Last update: <span id="lastUpdate">-</span>
    </div>
    <div id="chart"></div>
    <div class="info" id="contextText"></div>
    <div class="info" id="predictionText"></div>
    <div class="info">
      <small>⚠️ Harga = real dari Binance (klines 1m). Ghost candle = prediksi bentuk berikutnya (latihan baca candlestick), bukan sinyal wajib entry.</small>
    </div>
  </div>
</div>

<script>
  // ====== STATE ======
  let candles = [];        // data real
  const maxCandles = 200;  // batasi jumlah candle di chart
  let currentSymbol = "BTCUSDT";
  let pollingTimer = null;

  const statusText = document.getElementById("statusText");
  const lastUpdateEl = document.getElementById("lastUpdate");
  const contextEl = document.getElementById("contextText");
  const predictionEl = document.getElementById("predictionText");
  const symbolSelect = document.getElementById("symbolSelect");

  symbolSelect.value = currentSymbol;
  symbolSelect.addEventListener("change", () => {
    currentSymbol = symbolSelect.value;
    candles = [];
    updateChart(null);
    contextEl.textContent = "";
    predictionEl.textContent = "";
    lastUpdateEl.textContent = "-";
    statusText.textContent = "Change pair, loading...";
    startPolling();
  });

  // ====== CHART SETUP ======
  const container = document.getElementById("chart");
  const chart = LightweightCharts.createChart(container, {
    width: container.clientWidth,
    height: container.clientHeight,
    layout: { background: { color: "#020617" }, textColor: "#e5e7eb" },
    grid: {
      vertLines: { color: "#111827" },
      horzLines: { color: "#111827" },
    },
    timeScale: { timeVisible: true, secondsVisible: false },
  });

  const seriesReal = chart.addCandlestickSeries({
    upColor: "#22c55e",
    downColor: "#ef4444",
    borderUpColor: "#22c55e",
    borderDownColor: "#ef4444",
    wickUpColor: "#22c55e",
    wickDownColor: "#ef4444",
  });

  const seriesGhost = chart.addCandlestickSeries({
    upColor: "rgba(56,189,248,0.7)",
    downColor: "rgba(59,130,246,0.7)",
    borderUpColor: "rgba(56,189,248,0.9)",
    borderDownColor: "rgba(59,130,246,0.9)",
    wickUpColor: "rgba(56,189,248,0.9)",
    wickDownColor: "rgba(59,130,246,0.9)",
  });

  function updateChart(ghost) {
    const realData = candles.map(c => ({
      time: Math.floor(c.time / 1000),
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
    }));
    seriesReal.setData(realData);

    if (ghost) {
      const lastTime = candles.length
        ? Math.floor(candles[candles.length - 1].time / 1000)
        : Math.floor(Date.now() / 1000);
      seriesGhost.setData([{
        time: lastTime + 60, // candle berikutnya
        open: ghost.open,
        high: ghost.high,
        low: ghost.low,
        close: ghost.close,
      }]);
    } else {
      seriesGhost.setData([]);
    }

    chart.timeScale().fitContent();
  }

  window.addEventListener("resize", () => {
    chart.applyOptions({ width: container.clientWidth, height: 360 });
  });

  // ====== ANALISA SEDERHANA UNTUK GHOST ======
  function atrMini(data, period = 14) {
    if (data.length < 2) return 0;
    const start = Math.max(1, data.length - period);
    let sum = 0, count = 0;
    for (let i = start; i < data.length; i++) {
      const cur = data[i];
      const prev = data[i - 1];
      const tr = Math.max(
        cur.high - cur.low,
        Math.abs(cur.high - prev.close),
        Math.abs(cur.low - prev.close)
      );
      sum += tr;
      count++;
    }
    return count > 0 ? sum / count : 0;
  }

  function classifyLastCandle(c) {
    const body = Math.abs(c.close - c.open);
    const range = c.high - c.low || 1;
    const upperWick = c.high - Math.max(c.open, c.close);
    const lowerWick = Math.min(c.open, c.close) - c.low;
    const bodyPct = body / range;
    const upperPct = upperWick / range;
    const lowerPct = lowerWick / range;
    const dir = c.close >= c.open ? 1 : -1;

    if (bodyPct < 0.15 && upperPct > 0.2 && lowerPct > 0.2) {
      return { label: "doji", dir, bodyPct, upperPct, lowerPct };
    }
    if (lowerPct > 0.4 && dir >= 0) {
      return { label: "bull_reject_low", dir, bodyPct, upperPct, lowerPct };
    }
    if (upperPct > 0.4 && dir <= 0) {
      return { label: "bear_reject_high", dir, bodyPct, upperPct, lowerPct };
    }
    if (bodyPct > 0.6 && dir > 0) {
      return { label: "bull_momentum", dir, bodyPct, upperPct, lowerPct };
    }
    if (bodyPct > 0.6 && dir < 0) {
      return { label: "bear_momentum", dir, bodyPct, upperPct, lowerPct };
    }
    if (dir > 0) return { label: "bull_small", dir, bodyPct, upperPct, lowerPct };
    if (dir < 0) return { label: "bear_small", dir, bodyPct, upperPct, lowerPct };
    return { label: "neutral", dir: 0, bodyPct, upperPct, lowerPct };
  }

  function miniTrendDir(data, lookback = 20) {
    if (data.length < 2) return 0;
    const start = Math.max(0, data.length - lookback);
    const slice = data.slice(start);
    const first = slice[0].close;
    const last = slice[slice.length - 1].close;
    const diff = last - first;
    if (diff > 0) return 1;
    if (diff < 0) return -1;
    return 0;
  }

  function randBetween(a, b) {
    return a + Math.random() * (b - a);
  }

  function makeGhostCandle(last, history) {
    const atr = atrMini(history, 14) || (last.high - last.low || 1);
    const lastType = classifyLastCandle(last);
    const trendDir = miniTrendDir(history, 30);

    let dir = lastType.dir;
    if (Math.abs(dir) === 0) dir = trendDir || (Math.random() > 0.5 ? 1 : -1);

    let range = atr * randBetween(0.7, 1.3);
    if (!isFinite(range) || range <= 0) range = Math.abs(last.close || 1) * 0.003;

    let bodyFrac;
    if (lastType.label === "bull_momentum" || lastType.label === "bear_momentum") {
      bodyFrac = randBetween(0.6, 0.9);
    } else if (lastType.label === "bull_reject_low" || lastType.label === "bear_reject_high") {
      bodyFrac = randBetween(0.4, 0.7);
    } else if (lastType.label === "doji") {
      bodyFrac = randBetween(0.2, 0.5);
    } else {
      bodyFrac = randBetween(0.3, 0.6);
    }

    const wickTotal = Math.max(0, 1 - bodyFrac);
    let lowerWickFrac, upperWickFrac;

    if (dir > 0) {
      lowerWickFrac = randBetween(wickTotal * 0.4, wickTotal * 0.8);
      upperWickFrac = Math.max(0, wickTotal - lowerWickFrac);
    } else {
      upperWickFrac = randBetween(wickTotal * 0.4, wickTotal * 0.8);
      lowerWickFrac = Math.max(0, wickTotal - upperWickFrac);
    }

    const bodySize = range * bodyFrac;
    const lowerWick = range * lowerWickFrac;
    const upperWick = range * upperWickFrac;

    const open = last.close + randBetween(-atr * 0.05, atr * 0.05);
    const close = dir > 0 ? (open + bodySize) : (open - bodySize);
    const low = Math.min(open, close) - lowerWick;
    const high = Math.max(open, close) + upperWick;

    return {
      open, high, low, close,
      meta: { dir, range, bodyFrac, lowerWickFrac, upperWickFrac, lastType }
    };
  }

  function updateText(ghost) {
    if (!ghost) {
      contextEl.textContent = "Mengumpulkan data awal...";
      predictionEl.textContent = "";
      return;
    }
    const dirText = ghost.meta.dir > 0 ? "Bullish" : "Bearish";
    const bodyPct = (ghost.meta.bodyFrac * 100).toFixed(1);
    const lwPct = (ghost.meta.lowerWickFrac * 100).toFixed(1);
    const uwPct = (ghost.meta.upperWickFrac * 100).toFixed(1);

    const lt = ghost.meta.lastType;
    let lastDesc = "";
    if (lt.label === "bull_momentum") lastDesc = "bullish momentum (body besar, close dekat high)";
    else if (lt.label === "bear_momentum") lastDesc = "bearish momentum (body besar, close dekat low)";
    else if (lt.label === "bull_reject_low") lastDesc = "bullish rejection dari bawah (ekor bawah panjang)";
    else if (lt.label === "bear_reject_high") lastDesc = "bearish rejection dari atas (ekor atas panjang)";
    else if (lt.label === "doji") lastDesc = "doji / ragu-ragu";
    else if (lt.label === "bull_small") lastDesc = "bullish kecil";
    else if (lt.label === "bear_small") lastDesc = "bearish kecil";
    else lastDesc = "candle netral / kecil";

    contextEl.innerHTML = `Candle terakhir: <b>${lastDesc}</b>`;

    predictionEl.innerHTML = `
      <div class="tag">Arah ghost: <b>${dirText}</b></div>
      <div class="tag">Body relatif: ~<b>${bodyPct}%</b> dari range</div>
      <br>
      Perkiraan bentuk candle berikutnya (ghost biru):<br>
      - Wick bawah ~ <b>${lwPct}%</b> • Wick atas ~ <b>${uwPct}%</b><br>
      - Perkiraan range: ~<b>${ghost.meta.range.toFixed(2)}</b><br>
    `;
  }

  // ====== FETCH DATA DARI BINANCE (REST) ======
  async function fetchKlines(symbol) {
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1m&limit=200`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    const mapped = data.map(k => ({
      time: k[0],
      open: parseFloat(k[1]),
      high: parseFloat(k[2]),
      low: parseFloat(k[3]),
      close: parseFloat(k[4]),
    }));
    return mapped;
  }

  async function loadDataOnce() {
    try {
      statusText.textContent = `Loading ${currentSymbol}...`;
      const klines = await fetchKlines(currentSymbol);
      candles = klines.slice(-maxCandles);
      statusText.textContent = `OK (${currentSymbol})`;
      lastUpdateEl.textContent = new Date().toLocaleTimeString();
      if (candles.length < 20) {
        updateChart(null);
        updateText(null);
        return;
      }
      const last = candles[candles.length - 1];
      const ghost = makeGhostCandle(last, candles);
      updateChart(ghost);
      updateText(ghost);
    } catch (e) {
      console.error(e);
      statusText.textContent = "Error load data (cek internet / CORS).";
    }
  }

  function startPolling() {
    if (pollingTimer) clearInterval(pollingTimer);
    loadDataOnce();
    pollingTimer = setInterval(loadDataOnce, 5000); // refresh tiap 5 detik
  }

  // start
  startPolling();
</script>
</body>
</html>

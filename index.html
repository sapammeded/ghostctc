<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ REAL MARKET BANDIT DETECTOR - 100% REAL DATA</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f172a; 
            color: white;
            padding: 10px;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        .header { 
            text-align: center; 
            padding: 20px 0;
            border-bottom: 1px solid #1e293b;
            margin-bottom: 20px;
        }
        h1 { 
            color: #3b82f6; 
            font-size: 24px;
            margin-bottom: 5px;
        }
        .subtitle { color: #94a3b8; font-size: 14px; }
        
        .card {
            background: #1e293b;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #334155;
        }
        
        .card-title {
            color: #60a5fa;
            font-size: 16px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        select, input, button {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #475569;
            background: #0f172a;
            color: white;
            font-size: 14px;
            margin: 5px;
        }
        
        button {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            font-weight: bold;
            cursor: pointer;
        }
        
        button:hover { background: #2563eb; }
        
        .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        
        #chartContainer {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
            background: #0f172a;
        }
        
        .info-box {
            background: rgba(30, 41, 59, 0.5);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .log {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .success { color: #10b981; }
        .error { color: #ef4444; }
        .warning { color: #f59e0b; }
        
        .status {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .status.loading { background: rgba(59, 130, 246, 0.1); color: #60a5fa; }
        .status.success { background: rgba(16, 185, 129, 0.1); color: #10b981; }
        .status.error { background: rgba(239, 68, 68, 0.1); color: #ef4444; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ REAL MARKET BANDIT DETECTOR</h1>
            <div class="subtitle">100% Real Data dari Binance ‚Ä¢ Stop-Hunt Detection ‚Ä¢ Ghost Candle Prediction</div>
        </div>
        
        <div class="card">
            <div class="card-title">‚öôÔ∏è CONFIGURATION</div>
            <div class="row">
                <select id="pairSelect">
                    <option value="BTCUSDT">BTC/USDT</option>
                    <option value="ETHUSDT">ETH/USDT</option>
                    <option value="BNBUSDT">BNB/USDT</option>
                    <option value="XRPUSDT">XRP/USDT</option>
                    <option value="SOLUSDT">SOL/USDT</option>
                </select>
                
                <select id="tfSelect">
                    <option value="1m">1 Minute</option>
                    <option value="5m">5 Minutes</option>
                    <option value="15m">15 Minutes</option>
                    <option value="1h">1 Hour</option>
                    <option value="4h">4 Hours</option>
                    <option value="1d">1 Day</option>
                </select>
                
                <input type="number" id="candleCount" value="300" min="50" max="1000">
                
                <button onclick="loadRealData()">üì• LOAD REAL MARKET DATA</button>
                
                <button onclick="uploadCSV()" style="background: #059669;">üìÅ UPLOAD CSV</button>
            </div>
            
            <input type="file" id="csvUpload" accept=".csv" style="display: none;" onchange="handleCSVUpload(event)">
        </div>
        
        <div id="chartContainer"></div>
        
        <div class="card">
            <div class="card-title">üîç STOP-HUNT DETECTION</div>
            <div id="stopHuntInfo" class="info-box">
                Klik "LOAD REAL MARKET DATA" untuk memulai analisa
            </div>
        </div>
        
        <div class="card">
            <div class="card-title">üëª GHOST CANDLE PREDICTION</div>
            <div id="ghostPrediction" class="info-box">
                Prediction akan muncul setelah data di-load
            </div>
        </div>
        
        <div class="card">
            <div class="card-title">üìä LOGS & STATUS</div>
            <div id="statusLog" class="log">
                System ready. Select pair and timeframe.
            </div>
        </div>
    </div>

    <script>
        // ====== REAL MARKET DATA ======
        let chart = null;
        let candleSeries = null;
        let ghostSeries = null;
        let currentData = [];
        
        // Initialize chart
        function initChart() {
            const container = document.getElementById('chartContainer');
            
            if (chart) {
                chart.remove();
            }
            
            chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: 500,
                layout: {
                    background: { color: '#0f172a' },
                    textColor: '#f1f5f9',
                },
                grid: {
                    vertLines: { color: '#1e293b' },
                    horzLines: { color: '#1e293b' },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false,
                    borderColor: '#334155',
                },
            });
            
            candleSeries = chart.addCandlestickSeries({
                upColor: '#10b981',
                downColor: '#ef4444',
                borderUpColor: '#10b981',
                borderDownColor: '#ef4444',
                wickUpColor: '#10b981',
                wickDownColor: '#ef4444',
            });
            
            ghostSeries = chart.addCandlestickSeries({
                upColor: 'rgba(59, 130, 246, 0.7)',
                downColor: 'rgba(59, 130, 246, 0.7)',
                borderUpColor: 'rgba(59, 130, 246, 0.9)',
                borderDownColor: 'rgba(59, 130, 246, 0.9)',
                wickUpColor: 'rgba(59, 130, 246, 0.9)',
                wickDownColor: 'rgba(59, 130, 246, 0.9)',
            });
            
            logMessage('Chart initialized', 'success');
        }
        
        // ====== BINANCE API ======
        async function fetchBinanceData(symbol, interval, limit) {
            const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
            
            logMessage(`Fetching ${symbol} ${interval} data from Binance...`, 'loading');
            
            try {
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Convert Binance format
                const candles = data.map(kline => ({
                    time: Math.floor(kline[0] / 1000), // Convert to seconds
                    open: parseFloat(kline[1]),
                    high: parseFloat(kline[2]),
                    low: parseFloat(kline[3]),
                    close: parseFloat(kline[4]),
                    volume: parseFloat(kline[5]),
                }));
                
                logMessage(`‚úÖ Success: ${candles.length} candles loaded`, 'success');
                return candles;
                
            } catch (error) {
                logMessage(`‚ùå Error: ${error.message}`, 'error');
                
                // Fallback to alternative API
                return await fetchAlternativeData(symbol, interval, limit);
            }
        }
        
        // Alternative data source
        async function fetchAlternativeData(symbol, interval, limit) {
            logMessage('Trying alternative data source...', 'warning');
            
            try {
                // Use CoinGecko as backup
                const days = Math.ceil(limit * getMinutesFromTF(interval) / 1440);
                const url = `https://api.coingecko.com/api/v3/coins/${getCoinGeckoId(symbol)}/ohlc?vs_currency=usd&days=${days}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                const candles = data.map(item => ({
                    time: Math.floor(item[0] / 1000),
                    open: item[1],
                    high: item[2],
                    low: item[3],
                    close: item[4],
                    volume: 0,
                }));
                
                logMessage(`‚úÖ Alternative data loaded: ${candles.length} candles`, 'success');
                return candles;
                
            } catch (error) {
                logMessage('‚ùå All data sources failed. Using sample data.', 'error');
                return generateSampleData(symbol, limit);
            }
        }
        
        function getMinutesFromTF(tf) {
            const map = {
                '1m': 1, '5m': 5, '15m': 15, '1h': 60,
                '4h': 240, '1d': 1440, '1w': 10080
            };
            return map[tf] || 60;
        }
        
        function getCoinGeckoId(symbol) {
            const map = {
                'BTCUSDT': 'bitcoin',
                'ETHUSDT': 'ethereum',
                'BNBUSDT': 'binancecoin',
                'XRPUSDT': 'ripple',
                'SOLUSDT': 'solana'
            };
            return map[symbol] || 'bitcoin';
        }
        
        function generateSampleData(symbol, count) {
            const basePrice = symbol.includes('BTC') ? 70000 :
                             symbol.includes('ETH') ? 3500 :
                             symbol.includes('XRP') ? 0.6 : 100;
            
            const candles = [];
            let price = basePrice;
            
            for (let i = 0; i < count; i++) {
                const change = (Math.random() - 0.5) * basePrice * 0.02;
                const open = price;
                const close = price + change;
                const high = Math.max(open, close) + Math.random() * basePrice * 0.005;
                const low = Math.min(open, close) - Math.random() * basePrice * 0.005;
                
                candles.push({
                    time: Math.floor(Date.now() / 1000) - (count - i) * 3600,
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2)),
                    volume: Math.random() * 1000
                });
                
                price = close;
            }
            
            return candles;
        }
        
        // ====== CSV UPLOAD ======
        function uploadCSV() {
            document.getElementById('csvUpload').click();
        }
        
        async function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            logMessage(`Reading CSV file: ${file.name}`, 'loading');
            
            const text = await file.text();
            const candles = parseCSVData(text);
            
            if (candles.length > 0) {
                currentData = candles;
                updateChart(candles);
                analyzeData(candles);
                logMessage(`‚úÖ CSV loaded: ${candles.length} candles`, 'success');
            } else {
                logMessage('‚ùå Failed to parse CSV', 'error');
            }
        }
        
        function parseCSVData(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const candles = [];
            
            // Auto-detect format
            const header = lines[0].toLowerCase();
            
            lines.slice(1).forEach((line, index) => {
                const parts = line.split(',');
                
                let time, open, high, low, close;
                
                if (header.includes('date') && header.includes('time')) {
                    // Format: Date,Time,Open,High,Low,Close
                    const dateStr = parts[0] + ' ' + parts[1];
                    time = Math.floor(new Date(dateStr).getTime() / 1000);
                    open = parseFloat(parts[2]);
                    high = parseFloat(parts[3]);
                    low = parseFloat(parts[4]);
                    close = parseFloat(parts[5]);
                } else if (header.includes('timestamp')) {
                    // Unix timestamp
                    time = parseInt(parts[0]);
                    open = parseFloat(parts[1]);
                    high = parseFloat(parts[2]);
                    low = parseFloat(parts[3]);
                    close = parseFloat(parts[4]);
                } else {
                    // Simple format: open,high,low,close
                    time = Math.floor(Date.now() / 1000) - (lines.length - index) * 3600;
                    open = parseFloat(parts[0]);
                    high = parseFloat(parts[1]);
                    low = parseFloat(parts[2]);
                    close = parseFloat(parts[3]);
                }
                
                if (!isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close)) {
                    candles.push({ time, open, high, low, close, volume: 0 });
                }
            });
            
            // Reverse if needed (oldest first ‚Üí newest first)
            if (candles.length > 1 && candles[0].time > candles[candles.length-1].time) {
                candles.reverse();
            }
            
            return candles;
        }
        
        // ====== MAIN FUNCTIONS ======
        async function loadRealData() {
            const pair = document.getElementById('pairSelect').value;
            const tf = document.getElementById('tfSelect').value;
            const count = parseInt(document.getElementById('candleCount').value);
            
            if (!chart) initChart();
            
            const candles = await fetchBinanceData(pair, tf, count);
            
            if (candles.length > 0) {
                currentData = candles;
                updateChart(candles);
                analyzeData(candles);
            }
        }
        
        function updateChart(candles) {
            candleSeries.setData(candles);
            chart.timeScale().fitContent();
        }
        
        function analyzeData(candles) {
            if (candles.length < 50) {
                logMessage('Need at least 50 candles for analysis', 'warning');
                return;
            }
            
            // 1. Detect stop-hunts
            const stopHunts = detectStopHunts(candles);
            displayStopHuntInfo(stopHunts);
            
            // 2. Generate ghost prediction
            const ghost = predictGhostCandle(candles, stopHunts);
            displayGhostPrediction(ghost);
            
            // 3. Add ghost to chart
            if (ghost) {
                const lastTime = candles[candles.length - 1].time;
                const ghostTime = lastTime + getSecondsFromTF(document.getElementById('tfSelect').value);
                
                ghostSeries.setData([{
                    time: ghostTime,
                    open: ghost.open,
                    high: ghost.high,
                    low: ghost.low,
                    close: ghost.close,
                }]);
            }
        }
        
        function getSecondsFromTF(tf) {
            const map = {
                '1m': 60, '5m': 300, '15m': 900,
                '1h': 3600, '4h': 14400, '1d': 86400
            };
            return map[tf] || 3600;
        }
        
        // ====== STOP-HUNT DETECTION ======
        function detectStopHunts(candles) {
            const lookback = 20;
            const atr = calculateATR(candles, 14);
            const stopHunts = [];
            
            for (let i = lookback; i < candles.length - 1; i++) {
                const candle = candles[i];
                const prevHigh = Math.max(...candles.slice(i - lookback, i).map(c => c.high));
                const prevLow = Math.min(...candles.slice(i - lookback, i).map(c => c.low));
                
                const upperWick = candle.high - Math.max(candle.open, candle.close);
                const lowerWick = Math.min(candle.open, candle.close) - candle.low;
                const body = Math.abs(candle.close - candle.open);
                const range = candle.high - candle.low;
                
                const upperWickRatio = upperWick / range;
                const lowerWickRatio = lowerWick / range;
                
                // Bullish stop-hunt (swept lows)
                if (candle.low < prevLow - atr * 0.1 && 
                    lowerWickRatio > 0.4 &&
                    candle.close > prevLow) {
                    stopHunts.push({
                        type: 'BULLISH_STOP_HUNT',
                        index: i,
                        candle: candle,
                        confidence: Math.min(95, lowerWickRatio * 100)
                    });
                }
                
                // Bearish stop-hunt (swept highs)
                if (candle.high > prevHigh + atr * 0.1 && 
                    upperWickRatio > 0.4 &&
                    candle.close < prevHigh) {
                    stopHunts.push({
                        type: 'BEARISH_STOP_HUNT',
                        index: i,
                        candle: candle,
                        confidence: Math.min(95, upperWickRatio * 100)
                    });
                }
            }
            
            return stopHunts;
        }
        
        function calculateATR(candles, period) {
            if (candles.length < period + 1) return 0;
            
            let sum = 0;
            for (let i = 1; i <= period; i++) {
                const cur = candles[candles.length - i];
                const prev = candles[candles.length - i - 1];
                
                const tr = Math.max(
                    cur.high - cur.low,
                    Math.abs(cur.high - prev.close),
                    Math.abs(cur.low - prev.close)
                );
                sum += tr;
            }
            
            return sum / period;
        }
        
        function displayStopHuntInfo(stopHunts) {
            const infoEl = document.getElementById('stopHuntInfo');
            
            if (stopHunts.length === 0) {
                infoEl.innerHTML = `
                    <div class="warning">‚ö†Ô∏è No clear stop-hunt detected in current data</div>
                    <div style="font-size: 12px; color: #94a3b8; margin-top: 5px;">
                        Try loading more candles or different timeframe
                    </div>
                `;
                return;
            }
            
            const lastStopHunt = stopHunts[stopHunts.length - 1];
            const confidence = lastStopHunt.confidence.toFixed(0);
            
            infoEl.innerHTML = `
                <div class="success">‚úÖ STOP-HUNT DETECTED!</div>
                <div style="margin-top: 10px;">
                    <strong>Type:</strong> ${lastStopHunt.type === 'BULLISH_STOP_HUNT' ? 'Bullish (Low Sweep)' : 'Bearish (High Sweep)'}<br>
                    <strong>Confidence:</strong> ${confidence}%<br>
                    <strong>Price Level:</strong> ${lastStopHunt.type === 'BULLISH_STOP_HUNT' ? 
                        lastStopHunt.candle.low.toFixed(2) : lastStopHunt.candle.high.toFixed(2)}<br>
                    <strong>Total Detected:</strong> ${stopHunts.length} in current data
                </div>
                <div style="font-size: 12px; color: #94a3b8; margin-top: 10px;">
                    ${lastStopHunt.type === 'BULLISH_STOP_HUNT' ? 
                        'Lows were swept, potential bullish reversal' : 
                        'Highs were swept, potential bearish reversal'}
                </div>
            `;
        }
        
        // ====== GHOST CANDLE PREDICTION ======
        function predictGhostCandle(candles, stopHunts) {
            if (stopHunts.length === 0) return null;
            
            const lastCandle = candles[candles.length - 1];
            const lastStopHunt = stopHunts[stopHunts.length - 1];
            const atr = calculateATR(candles, 14);
            
            // Determine direction based on last stop-hunt
            let direction;
            if (lastStopHunt.type === 'BULLISH_STOP_HUNT') {
                direction = 1; // Bullish
            } else {
                direction = -1; // Bearish
            }
            
            // Calculate expected range
            const range = atr * (0.8 + Math.random() * 0.4);
            const bodyRatio = 0.6 + Math.random() * 0.3;
            const bodySize = range * bodyRatio;
            
            const open = lastCandle.close;
            const close = direction > 0 ? open + bodySize : open - bodySize;
            
            // Determine wicks
            const wickRatio = 1 - bodyRatio;
            let upperWick, lowerWick;
            
            if (direction > 0) {
                lowerWick = range * wickRatio * (0.2 + Math.random() * 0.3);
                upperWick = range * wickRatio - lowerWick;
            } else {
                upperWick = range * wickRatio * (0.2 + Math.random() * 0.3);
                lowerWick = range * wickRatio - upperWick;
            }
            
            const high = Math.max(open, close) + upperWick;
            const low = Math.min(open, close) - lowerWick;
            
            return {
                open: parseFloat(open.toFixed(2)),
                high: parseFloat(high.toFixed(2)),
                low: parseFloat(low.toFixed(2)),
                close: parseFloat(close.toFixed(2)),
                direction: direction > 0 ? 'BULLISH' : 'BEARISH',
                confidence: lastStopHunt.confidence * 0.8,
                basedOn: lastStopHunt.type
            };
        }
        
        function displayGhostPrediction(ghost) {
            const infoEl = document.getElementById('ghostPrediction');
            
            if (!ghost) {
                infoEl.innerHTML = `
                    <div class="warning">‚ö†Ô∏è No ghost prediction available</div>
                    <div style="font-size: 12px; color: #94a3b8;">
                        Need stop-hunt detection first
                    </div>
                `;
                return;
            }
            
            infoEl.innerHTML = `
                <div class="success">üëª GHOST CANDLE PREDICTION</div>
                <div style="margin-top: 10px;">
                    <strong>Direction:</strong> <span style="color: ${ghost.direction === 'BULLISH' ? '#10b981' : '#ef4444'}">
                        ${ghost.direction}
                    </span><br>
                    <strong>Expected Range:</strong> ${(ghost.high - ghost.low).toFixed(2)}<br>
                    <strong>Open:</strong> ${ghost.open} ‚Üí <strong>Close:</strong> ${ghost.close}<br>
                    <strong>Confidence:</strong> ${ghost.confidence.toFixed(0)}%<br>
                    <strong>Based on:</strong> ${ghost.basedOn === 'BULLISH_STOP_HUNT' ? 'Bullish Stop-Hunt' : 'Bearish Stop-Hunt'}
                </div>
                <div style="font-size: 12px; color: #94a3b8; margin-top: 10px;">
                    Blue candle on chart shows predicted next candle
                </div>
            `;
        }
        
        // ====== UTILITIES ======
        function logMessage(message, type = 'info') {
            const logEl = document.getElementById('statusLog');
            const time = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'error' : 
                              type === 'success' ? 'success' : 
                              type === 'warning' ? 'warning' : 'info';
            
            const entry = document.createElement('div');
            entry.className = colorClass;
            entry.innerHTML = `[${time}] ${message}`;
            
            logEl.prepend(entry);
            
            // Keep only last 20 entries
            const entries = logEl.querySelectorAll('div');
            if (entries.length > 20) {
                entries[entries.length - 1].remove();
            }
        }
        
        // Initialize
        window.onload = function() {
            initChart();
            logMessage('System initialized. Ready to load real market data.', 'success');
            
            // Auto-load BTC 1h data
            setTimeout(() => {
                loadRealData();
            }, 1000);
        };
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (chart) {
                chart.applyOptions({
                    width: document.getElementById('chartContainer').clientWidth
                });
            }
        });
    </script>
</body>
</html>
